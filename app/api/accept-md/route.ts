// Generated by accept-md. Do not edit the markdown block by hand.
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { getMarkdownForPath, loadConfig } from "accept-md-runtime";

const cache = new Map();
const HANDLER_PATH = "/api/accept-md";

export async function GET(request: NextRequest) {
  const pathFromHeader = request.headers.get("x-accept-md-path");
  const pathFromQuery = request.nextUrl.searchParams.get("path");
  // Headers that may carry the original matched path when using rewrites on Vercel/Next.js
  const pathFromMatchedHeader =
    request.headers.get("x-matched-path") ||
    request.headers.get("x-vercel-original-path") ||
    request.headers.get("x-original-path") ||
    request.headers.get("x-rewrite-path");
  const pathname = request.nextUrl.pathname;
  // Never use the handler path itself - always prefer, in order:
  // 1) explicit header, 2) internal matched-path header, 3) query param, 4) pathname (if not handler), then default to '/'
  let path = pathFromHeader && pathFromHeader.trim() !== "" ? pathFromHeader : null;
  if (!path && pathFromMatchedHeader && pathFromMatchedHeader.trim() !== "") {
    path = pathFromMatchedHeader;
  }
  if (!path && pathFromQuery && pathFromQuery.trim() !== "") {
    path = pathFromQuery;
  }
  // If pathname starts with /api/accept-md, extract the original path from it
  // This handles next.config rewrites that use /api/accept-md/:path* pattern
  if (!path && pathname.startsWith(HANDLER_PATH + "/")) {
    path = pathname.slice(HANDLER_PATH.length);
    // Handle root path case: /api/accept-md/ becomes /
    if (path === "") {
      path = "/";
    }
  }
  if (!path) {
    path = pathname !== HANDLER_PATH ? pathname : null;
  }
  if (!path || path === HANDLER_PATH) {
    path = "/";
  }
  // Ensure path starts with /
  if (!path.startsWith("/")) {
    path = "/" + path;
  }
  // Exclude /api and /_next paths - return 404 for these
  if (path.startsWith("/api/") || path.startsWith("/_next/")) {
    return NextResponse.json({ error: "Not found" }, { status: 404 });
  }
  const config = loadConfig(process.cwd());
  // Construct baseUrl reliably: prefer config, then use request origin, fall back to localhost
  let baseUrl = config.baseUrl;
  if (!baseUrl) {
    baseUrl = request.nextUrl.origin || "http://localhost:" + (process.env.PORT || 3000);
  }
  // Forward headers but avoid sending markdown Accept header to the upstream page fetch
  const headers = new Headers(request.headers);
  headers.delete("accept");
  // Bypass Vercel deployment protection on self-fetches (the internal .vercel.app
  // URL is protected under Standard Protection even for production deployments).
  if (process.env.VERCEL_AUTOMATION_BYPASS_SECRET) {
    headers.set("x-vercel-protection-bypass", process.env.VERCEL_AUTOMATION_BYPASS_SECRET);
  }
  try {
    const markdown = await getMarkdownForPath({
      pathname: path,
      baseUrl,
      config,
      cache: config.cache !== false ? cache : undefined,
      headers,
    });
    return new NextResponse(markdown, {
      headers: {
        "Content-Type": "text/markdown; charset=utf-8",
        "Cache-Control": config.cache ? "public, s-maxage=60, stale-while-revalidate" : "no-store",
      },
    });
  } catch (err) {
    return NextResponse.json(
      { error: err instanceof Error ? err.message : "Markdown generation failed" },
      { status: 500 }
    );
  }
}
