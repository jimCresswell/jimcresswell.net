# ADR-009: Content negotiation via Next.js proxy

## Status

Accepted

## Date

2026-02-15 (amended 2026-02-23: self-fetch routing)

## Context

The site now serves multiple representations of the same content:

- **HTML** — the default browser experience.
- **Markdown** — clean markdown with YAML frontmatter, intended for AI systems, LLM crawlers, and tools that work with plain-text content.
- **JSON-LD** — the Schema.org knowledge graph, intended for structured-data consumers.
- **PDF** — the downloadable CV (separate mechanism, see ADR-001/002).

Each representation is a view onto the same underlying reality — the same entities, the same editorial content, just serialised differently. The question is how to route requests to the correct representation.

### Requirements

1. **HTTP content negotiation** — `Accept: text/markdown` returns markdown, `Accept: application/ld+json` returns the knowledge graph.
2. **Browser-friendly aliases** — Visitors should be able to type `/cv.md` or `/cv/index.md` in a browser address bar and get markdown without setting custom headers.
3. **API routes must not be intercepted** — `/api/graph`, `/api/accept-md`, `/cv/pdf` must serve their native responses regardless of `Accept` headers.
4. **No regex in config** — Earlier iterations used a regex-based `beforeFiles` rewrite in `next.config.ts`. This was fragile and hard to read ("when you solve a problem with regex, now you have two problems"). The routing logic should be expressed as plain TypeScript.

### Options evaluated

1. **Rewrites in `next.config.ts` with regex.** The original approach. A `beforeFiles` rewrite matched `/:path((?!api|_next).*)*` with a `has` condition on the `Accept` header. Worked but was opaque: the regex excluded API paths via negative lookahead, and the rewrite destination passed the path as a query parameter. Difficult to extend for `.md` suffix aliases or JSON-LD negotiation without stacking more regex.

2. **Next.js proxy (`proxy.ts`).** The Next.js 16 successor to `middleware.ts`. A single TypeScript function that inspects the request and rewrites, redirects, or passes through. The matcher config excludes static assets and API routes at the framework level. All negotiation logic lives in readable conditionals.

3. **Per-route content negotiation.** Each `page.tsx` inspects the `Accept` header and returns the appropriate format. Would couple every page to the markdown/JSON-LD generation logic and violate separation of concerns.

## Decision

**Option 2 — Next.js proxy (`proxy.ts`) for all content negotiation.**

The proxy handles three cases, evaluated in order:

| Condition                                      | Action                                     |
| ---------------------------------------------- | ------------------------------------------ |
| URL ends with `.md`                            | Strip suffix, rewrite to accept-md handler |
| `Accept` header includes `text/markdown`       | Rewrite to accept-md handler               |
| `Accept` header includes `application/ld+json` | Rewrite to `/api/graph` (knowledge graph)  |
| None of the above                              | Pass through to normal page rendering      |

### Markdown serving

Markdown is generated by `accept-md-runtime`, a library that fetches the page's HTML internally, strips navigation/chrome, and converts the content to markdown with YAML frontmatter. The runtime is invoked via the Route Handler at `app/api/accept-md/route.ts`.

The `.md` suffix aliases support two patterns:

| URL pattern        | Resolves to page | Example                |
| ------------------ | ---------------- | ---------------------- |
| `/<page>.md`       | `/<page>`        | `/cv.md` → `/cv`       |
| `/<page>/index.md` | `/<page>`        | `/cv/index.md` → `/cv` |
| `/index.md`        | `/`              | `/index.md` → `/`      |

This means every page can be accessed as markdown using either pattern — whichever the visitor finds more natural.

### Preventing infinite loops

When the proxy rewrites `/cv.md` to `/api/accept-md?path=/cv`, Next.js sets an `x-matched-path` internal header on the rewritten request — and that header contains the _original_ path (`/cv.md`). The accept-md handler reads `x-matched-path` as a high-priority path source. If it then fetches `/cv.md` internally, the proxy intercepts it again: infinite loop.

The fix: the proxy sets `x-accept-md-path` (the handler's _highest_-priority header) to the resolved page path. The handler uses this instead of `x-matched-path`, breaking the cycle.

### Self-fetch routing in production

The accept-md handler works by fetching the page's own HTML from itself — a self-fetch. In development this hits `localhost` and works without issue. In production, the deployment sits behind two layers of protection that both block self-fetches:

1. **Cloudflare** — the public domain (`www.jimcresswell.net`) routes through Cloudflare, which blocks automated traffic by default (Super Bot Fight Mode). The handler's server-side `fetch()` looks like bot traffic to Cloudflare.
2. **Vercel deployment protection** — Standard Protection is enabled, which protects all domains except the production custom domain. The internal `.vercel.app` deployment URL is therefore protected and returns 401 for unauthenticated requests.

The handler's `baseUrl` determines which URL it self-fetches from. By default it uses `request.nextUrl.origin`, which resolves to the public domain — hitting Cloudflare. The library falls back to `VERCEL_URL` (the `.vercel.app` URL), but that is blocked by deployment protection.

The fix uses both Vercel mechanisms to bypass both layers:

- **`accept-md.config.js`** sets `baseUrl` to `https://${VERCEL_URL}` when on Vercel. Self-fetches go directly to Vercel's infrastructure via the `.vercel.app` domain, bypassing Cloudflare entirely. Locally, `VERCEL_URL` is unset so the handler falls back to `localhost`.
- **`app/api/accept-md/route.ts`** adds the `x-vercel-protection-bypass` header using `VERCEL_AUTOMATION_BYPASS_SECRET` (a Vercel system environment variable). This lets self-fetches through Standard Protection on the `.vercel.app` URL.

This means the self-fetch never leaves Vercel's infrastructure — it does not traverse the public internet or the Cloudflare proxy. Cloudflare's bot protection can remain fully enabled.

### JSON-LD content negotiation

Requesting any page with `Accept: application/ld+json` returns the full Schema.org knowledge graph (see ADR-010 for the rationale behind "full graph, not per-page subgraph"). The proxy simply rewrites to `/api/graph`, which serves the same graph that appears as `<script type="application/ld+json">` on the CV page.

### `proxy.ts` vs `middleware.ts`

Next.js 16 renamed the `middleware` file convention to `proxy`. The function export is `proxy`, not `middleware`. The rename reflects Next.js's intention that this mechanism should be used for request-level routing (like a reverse proxy) rather than application-level logic. Content negotiation is squarely in that category.

## Consequences

**Benefits:**

- All content negotiation logic lives in a single, readable TypeScript file. No regex in config. Each case is a plain conditional with a clear comment.
- Adding new representations (e.g. `Accept: text/turtle` for RDF) means adding one `if` block in the proxy.
- The `.md` suffix aliases make markdown accessible in any browser without developer tools. This is important for human visitors who want to read the source content.
- JSON-LD content negotiation follows Linked Data conventions: request a resource with `Accept: application/ld+json`, get structured data. This works with standard Linked Data tooling.
- API routes are excluded at the matcher level — they never enter the proxy function.

**Trade-offs:**

- The proxy runs on every non-static, non-API request. The logic is fast (string comparisons on the path and `Accept` header), but it is an extra function invocation per request. Next.js proxies are designed for this and can run at the edge.
- The `x-accept-md-path` header is a coupling between the proxy and the accept-md handler. If the handler's header priority changes, the proxy must be updated. This is documented in the proxy's TSDoc.
- The `accept-md-runtime` dependency is a third-party library. It is dynamically configured via `accept-md.config.js`. If the library changes its API, the handler and config need updating.
- The self-fetch bypass relies on two Vercel-specific mechanisms (`VERCEL_URL` and `VERCEL_AUTOMATION_BYPASS_SECRET`). If deployment protection settings change, or if the bypass secret is rotated, the self-fetch will break with a 401. The E2E test suite (`markdown-content-negotiation.e2e-api.test.ts`) covers all markdown routes and will catch this locally, but production failures require checking Vercel logs.

## Related

- [ADR-007: DRY content and metadata consolidation](007-dry-content-metadata.md) — the content negotiation serves different views of the same single source
- [ADR-008: Schema.org compliance](008-schema-org-compliance.md) — the JSON-LD content negotiation serves a Schema.org-compliant graph
- [ADR-010: Canonical URL and graph identity](010-canonical-url-graph-identity.md) — documents why JSON-LD negotiation returns the full graph
- `proxy.ts` — the proxy implementation
- `app/api/accept-md/route.ts` — the markdown generation handler
- `app/api/graph/route.ts` — the knowledge graph endpoint
- `accept-md.config.js` — accept-md runtime configuration
